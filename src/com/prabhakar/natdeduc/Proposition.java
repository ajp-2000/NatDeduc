/* A class to be bulit up incrementally, such that any proposition comes down to
 * relations of atomic propositions, which have nothing 'to' them, just a name for reference.
 * The ways in which instances of Proposition relate captures all of 
 * what would have been articulated by brackets in a string.
 * Once a Proposition object has been produced, everything is grammatical.
 */

package com.prabhakar.natdeduc;

import java.util.*;

public class Proposition {
	boolean atomic;
	Proposition place1, place2;
	int places;
	char operation;
	String name;
	
	public Proposition(char n) {
		atomic = true;
		places = 0;
		name = Character.toString(n);
	}
	
	public Proposition(char n, Map<Character, Proposition> escapeProps) {
		if (escapeProps.containsKey(n)) {
			Proposition p = escapeProps.get(n);
			this.atomic = p.atomic;
			this.place1 = p.place1;
			this.place2 = p.place2;
			this.places = p.places;
			this.operation = p.operation;
			this.name = p.name;
		} else {
			atomic = true;
			places = 0;
			name = Character.toString(n);
		}
	}
	
	public Proposition(char o, Proposition p1, String n) {
		atomic = false;
		operation = o;
		place1 = p1;
		places = 1;
		name = n;
		
		if (operation=='~') operation = '¬';
	}
	
	public Proposition(Proposition p1, char o, Proposition p2, String n) {
		atomic = false;
		operation = o;
		place1 = p1;
		place2 = p2;
		places = 2;
		name = n;
		
		if (operation=='&') operation = '∧';
	}
	
	// Return an object which is the input, but within an assumption block
	public Proposition makeAssump(char assumpChar) {
		return new Proposition(assumpChar, this, this.name);
	}
	
	public boolean sameAs(Proposition target) {
		if (this.atomic || target.atomic) {
			if (!this.atomic || !target.atomic) {
				return false;
			}
			
			if (this.name.equals(target.name)) {
				return true;
			}
			
			return false;
		}
		
		if (this.places==1) {
			if (target.places!=1) {
				return false;
			}
			
			if (this.operation==target.operation && this.place1.sameAs(target.place1)) {
				return true;
			}
			
			return false;
		}
		
		if (this.places==2) {
			if (target.places!=2) {
				return false;
			}
			
			if (this.operation==target.operation && 
					this.place1.sameAs(target.place1) && 
					this.place2.sameAs(target.place2)) {
				return true;
			}
		}
		
		
		return false;
	}
	
	// This will break if arr1 and arr2 have different lengths
	public boolean[] mergeBoolArrays(boolean[] arr1, boolean[] arr2) {
		boolean[] result = new boolean[arr1.length];
		
		for (int i=0; i<arr1.length; i++) {
			result[i] = arr1[i] | arr2[i];
		}
		
		return result;
	}
	
	// Return the atomic propositions in this proposition, as a 26-long bool array
	public boolean[] countAtomic() {
		boolean[] found = new boolean[26];
		
		// Recursivity
		if (this.atomic) {
			found[name.toCharArray()[0] - (int)'a'] = true;
			return found;
		} else {
			found = mergeBoolArrays(found, place1.countAtomic());
			if (places==2) {
				found = mergeBoolArrays(found, place2.countAtomic());
			}
		}
		
		return found;
	}
	
	// Set name to something that represents the proposition. Recursively, so that we only need
	// to call this once, on the highest-order prop (and only when the props were generated by
	// seedProp, else they should already have sensible names).
	public void configName() {
		// Recurse
		if (!this.atomic) {
			place1.configName();
			if (places==2) {
				place2.configName();
			}
		}
		
		// The base case is already ok - or if not, things are irredeemable
		if (this.atomic) {
			return;
		}
		
		// The recursive step
		String name1;
		if (place1.atomic) {
			name1 = place1.name;
		} else {
			name1 = "(" + place1.name + ")";
		}
		
		if (places==1) {
			this.name = this.operation + name1;
			return;
		} else {
			String name2;
			if (place2.atomic) {
				name2 = place2.name;
			} else {
				name2 = "(" + place2.name + ")";
			}
			
			this.name = name1 + " " + this.operation + " " + name2;
		}
	}
	
	public void print() {
		if (atomic) {
			System.out.println("Atomic proposition");
			System.out.printf("Name %s\n\n", name);
		}
		
		if (place1!=null && place2==null) {
			System.out.println("One-place proposition");
			System.out.printf("Operation %c\n", operation);
			System.out.printf("Place %s\n", place1.name);
			System.out.printf("Name %s\n\n", name);
		}
		
		if (place1!=null && place2!=null) {
			System.out.println("Two-place proposition");
			System.out.printf("Operation %c\n", operation);
			System.out.printf("Place1 %s\n", place1.name);
			System.out.printf("Place2 %s\n", place2.name);
			System.out.printf("Name %s\n\n", name);
		}
	}
}